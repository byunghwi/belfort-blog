---
title: "Openlayers, Turf.js ë¥¼ ì‚¬ìš©í•œ NOTAM ë Œë”ë§"
excerpt: "OpenLayers, Turf.js ë¥¼ í™œìš©í•˜ì—¬ êµ­í† ì •ë³´í”Œë«í¼ LX ì§€ë„ ë ˆì´ì–´ ìƒì„± ë° ë„í˜• ë Œë”ë§"
coverImage: "/assets/notam/notam.png"
date: "2020-03-16T05:35:07.322Z"
author:
  name: Byunghwi Ko
---
# Openlayers, Turf.js ë¥¼ ì‚¬ìš©í•œ NOTAM ë Œë”ë§

Created: 2024ë…„ 8ì›” 9ì¼ ì˜¤í›„ 1:46
Tags: Openlayers, Turf.js

### ë“¤ì–´ê°€ê¸° ì „

<aside>
ğŸ’¡ **NOTAM**ì€ "Notice to Airmen"ì˜ ì•½ìë¡œ, í•­ê³µ ìš´í•­ì— ì¤‘ìš”í•œ ì •ë³´ë¥¼ ì „ë‹¬í•˜ê¸° ìœ„í•´ ë°œí–‰ë˜ëŠ” ê³µì‹ í†µì§€ì„œ. NOTAMì€ í•­ë¡œ, ê³µí•­, í•­ê³µê¸° ê´€ë ¨ ì‹œì„¤ì˜ ìƒíƒœë‚˜ ì¼ì‹œì ì¸ ë³€ê²½ ì‚¬í•­, ìœ„í—˜ ìš”ì†Œ ë“± í•­ê³µê¸°ì˜ ì•ˆì „í•œ ìš´í•­ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆëŠ” ì •ë³´ë¥¼ í¬í•¨. ì¡°ì¢…ì‚¬, í•­ê³µ ê´€ì œì‚¬, í•­ê³µì‚¬ ìš´ì˜ì ë“± í•­ê³µì—…ê³„ ì¢…ì‚¬ìë“¤ì´ ë¹„í–‰ ê³„íšì„ ì„¸ìš°ê¸° ì „ì— ë°˜ë“œì‹œ í™•ì¸í•´ì•¼ í•˜ëŠ” ì¤‘ìš”í•œ ë¬¸ì„œ

</aside>

<aside>
ğŸ’¡ **Turf.js**ëŠ” ì§€ë¦¬ ê³µê°„ ë°ì´í„°ë¥¼ ë‹¤ë£¨ê¸° ìœ„í•œ ê°•ë ¥í•œ JavaScript ë¼ì´ë¸ŒëŸ¬ë¦¬
  https://turfjs.org/

</aside>

---

### êµ¬í˜„ ëª©ì  ë° ë°©ë²•

**Why**: AIM í•­ê³µì •ë³´í†µí•©ê´€ë¦¬ì˜ í•­ê³µê³ ì‹œë³´(NOTAM) ì •ë³´ë¥¼ APIë¡œ í˜¸ì¶œ ë° ì§€ë„ì— í‘œì¶œí•˜ê¸° ìœ„í•¨

**How:** `OpenLayers`, `Turf.js` ë¥¼ í™œìš©í•˜ì—¬ êµ­í† ì •ë³´í”Œë«í¼ LX ì§€ë„ ë ˆì´ì–´ ìƒì„± ë° ë„í˜• ë Œë”ë§

---

**AIM í•­ê³µì •ë³´í†µí•©ê´€ë¦¬ì˜ í•­ê³µê³ ì‹œë³´(NOTAM)**

![aim_notam1](/assets/notam/aim_notam1.png)

![aim_notam2](/assets/notam/aim_notam2.png)

---

### êµ¬í˜„ ê²°ê³¼ í™”ë©´

- **Image 1**

![notam.png](/assets/notam/notam.png)

<aside>
â—¾ NOTAM ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë„ì‹í™”, ë™ì¼ ì¢Œí‘œ NOTAMì€ í´ëŸ¬ìŠ¤í„°ë§í•˜ì—¬ í´ë¦­ ì‹œ  í•´ë‹¹ ì¢Œí‘œì— í¬í•¨ëœ ì—¬ëŸ¬ ê°œì˜ NOTAM í¬ì¸íŠ¸ í‘œì¶œ

</aside>

- **Image 2**

![halfCircle](/assets/notam/halfCircle.png)

<aside>
â—¾ Turf.js ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ semicircle(ë°˜ì›) ì—ì„œ ì›í•˜ëŠ” ë„í˜•ë§Œí¼ ì œì™¸í•œ ì°¨ì§‘í•© ë„ì‹ ë Œë”ë§(ë³´ë¼ìƒ‰ ë„í˜•).

</aside>

- **Image 3**

![shapes.png](/assets/notam/shapes.png)

<aside>
â—¾ ê°œë³„ ì•„ì´ì½˜ í´ë¦­ ì‹œ NOTAM ì •ë³´ íŒì—… Overlayí‘œì¶œ

</aside>

---

### ì½”ë“œ

**weatherStore.js**

- **getNOTAMs()**

```jsx
const getNOTAMs = async () => {
    try {
      let response = await apiService.getNotams();
      if (response.DATA.length > 0) {
        let notamArr = response.DATA;
        notamArr.forEach(notam => {
          notams.value[notam.NOTAM_NO] = notam;
        })
      }
    } catch (error) {
      console.log(error);
    }
  }
```

<aside>
â—¾

RestAPI ìš”ì²­ì„ í†µí•´ NOTAM ì •ë³´ fetch

</aside>

- getCenterCoord()

```jsx
  const getCenterCoord = (item) => {
    let type = (Object.keys(item.eCoord).length > 0) ? Object.keys(item.eCoord)[0] : 'circle';
    let exc = (item?.eCoord?.exc) ? true : false;
    let centerCoord;
    let parsePoints;
    let lon, lat;
    let centerPoint, startPoint, endPoint;

    switch (type) {
      case 'polygon':
        if (exc) {
          console.log("polygon ì¸ë° exc ìˆì„ ë–„");
        } else {
          parsePoints = parsePolygonCoordinates(item.eCoord.polygon, type);
          centerCoord = calculatePolygonCenter(parsePoints[0]);
        }
        break;
      case 'circle': // circleì€ eCoordì— ëª…ì‹œëœ ê²ƒ, ëª…ì‹œì•ˆëœ ê²ƒ ë‘ ê°€ì§€ ì¡´ì¬.
        if (Object.keys(item.eCoord).length > 0) {
          lon = item.eCoord.circle.centerPoint.lon;
          lat = item.eCoord.circle.centerPoint.lat;
        } else {
          lon = item.qCoord.data.lon;
          lat = item.qCoord.data.lat;
        }

        if (exc) {
          console.log('circle ì¸ë° exc ìˆì„ ë–„');
        } else {
          centerCoord = transform([lon, lat], 'EPSG:4326', 'EPSG:5179')
        }

        break;
      case 'semicircle':
        if (exc) { // excê°€ ì¡´ì¬í•˜ë©´ í•´ë‹¹ ì˜ì—­ ì œì™¸í•´ì£¼ê¸°
          centerPoint = [item.eCoord.semicircle.centerPoint.lon, item.eCoord.semicircle.centerPoint.lat];
          startPoint = [item.eCoord.semicircle.startPoint.lon, item.eCoord.semicircle.startPoint.lat];
          endPoint = [item.eCoord.semicircle.endPoint.lon, item.eCoord.semicircle.endPoint.lat];

          centerPoint = transform(centerPoint, 'EPSG:4326', 'EPSG:5179')
          centerCoord = centerPoint;
        } else {
          //ìš°ì„  ê·¸ë¦¬ê¸°ë¶€í„° í•´ë³´ì..
          centerPoint = [item.eCoord.semicircle.centerPoint.lon, item.eCoord.semicircle.centerPoint.lat];
          startPoint = [item.eCoord.semicircle.startPoint.lon, item.eCoord.semicircle.startPoint.lat];
          endPoint = [item.eCoord.semicircle.endPoint.lon, item.eCoord.semicircle.endPoint.lat];

          centerPoint = transform(centerPoint, 'EPSG:4326', 'EPSG:5179')
          centerCoord = centerPoint;
        }
        break;
      case 'polyline':
        if (exc) {
          console.log("polyline ì¸ë° exc ìˆì„ ë–„");
        } else {
          centerCoord = parsePolygonCoordinates(item.eCoord.polyline.polygon_centroid, 'line')
        }
        break;
      default:
        console.log(`Unknown type: ${item.eCoord}`);
        return;
    }

    storeMap.goCenter(centerCoord) ;
  }
```

<aside>
â—¾

BackEndì—ì„œ ìˆ˜ì‹ í•œ ë„í˜•ì˜ ì •ë³´ì— ë”°ë¼ coordinate ê³„ì‚°

</aside>

- **showNotam()**

```
const showNotam = async (notamList) => {
    try {
      let circleFeatures = [];
      let iconFeatures = [];
      let polygonFeatures = [];
      let polyFeature;   // eCoord ì •ì˜ëœ feature
      let circleFeature; // eCoord ì •ì˜ ì—†ëŠ” qCoord ì°¸ì¡° feature
      let centerCoord;
      if(notamList.length > 0) {
        notamList.forEach((ind) => {
          if (ind.eCoord && Object.keys(ind.eCoord).length > 0) { // eCoord type ì •í•´ì ¸ìˆëŠ” ì• ë“¤...
            [polyFeature, centerCoord] = drawNotamByShape(ind.NOTAM_NO, ind.eCoord, null);
            if (polyFeature != undefined) polygonFeatures.push(polyFeature);
          } else {
            [circleFeature, centerCoord] = drawNotamByShape(ind.NOTAM_NO, null, ind.qCoord);
            if (circleFeature != undefined) {
              circleFeatures.push(circleFeature);
            }
          }
          if (centerCoord) {
            //ì•„ì´ì½˜ FeatureëŠ” ê³µí†µ
            const iconFeature = new Feature({
              geometry: new Point([centerCoord[0], centerCoord[1]]),
              info: ind.FULL_TEXT,
              notamNo: ind.NOTAM_NO,
              type: 'notam'
            });

            iconFeatures.push(iconFeature);
          }
        })
      }

      if (storeMap.getLayer('notamLayer')) {
        layerGroup.value['notamLayer'].getSource().clear();
        layerGroup.value['notamLayer'].getSource().addFeatures([...circleFeatures, ...polygonFeatures]); // ìƒˆë¡œìš´ ë°ì´í„° ì¶”ê°€

        if (layerGroup.value['notamClusterLayer']) {
          const iconSource = new VectorSource({
            features: iconFeatures
          });

          const clusterSource = new Cluster({
            distance: 5, // í´ëŸ¬ìŠ¤í„°ë§ ê±°ë¦¬
            source: iconSource
          });
          layerGroup.value['notamClusterLayer'].setSource(clusterSource);
        }
      } else {
        const vectorSource = new VectorSource({
          features: [...circleFeatures, ...polygonFeatures]
        });

        const notamLayer = new VectorLayer({
          source: vectorSource,
          zIndex: 3,
          name: 'notamLayer',
          style: (feature) => storeMap.layerStyleFunc('notamLayer', feature)
        });

        storeMap.addLayer('notamLayer', notamLayer);

        // í´ëŸ¬ìŠ¤í„°ë§ì„ ìœ„í•œ ì•„ì´ì½˜ í”¼ì²˜ ìƒì„±
        const iconSource = new VectorSource({
          features: iconFeatures
        });

        const clusterSource = new Cluster({
          distance: 5, // í´ëŸ¬ìŠ¤í„°ë§ ê±°ë¦¬
          source: iconSource
        });

        const clusterLayer = new VectorLayer({
          source: clusterSource,
          zIndex: 3,
          name: 'notamClusterLayer',
          style: (feature) => storeMap.layerStyleFunc('notamClusterLayer', feature),
        });

        storeMap.addLayer('notamClusterLayer', clusterLayer);
      }

      // if(centerCoord) {
      //   storeMap.goCenter(centerCoord)
      // }
    } catch (error) {
      console.log(error);
    }
  }

```

<aside>
â—¾

fetchí•œ NOTAM ì •ë³´ë¥¼ ì½ì–´ drawNotamByShape í•¨ìˆ˜í˜¸ì¶œ

</aside>

- **drawNotamByShape()**

NOTAM ì •ë³´ë“¤ì„ í† ëŒ€ë¡œ ê° ìœ í˜•ì— ë§ë„ë¡ feature ìƒì„± 

```jsx
 // ë„í˜• íƒ€ì…ì— ë§ê²Œ Feature ìƒì„±
  const drawNotamByShape = (notamNo, eCoord, qCoord) => {
    let type = (eCoord) ? Object.keys(eCoord)[0] : 'circle';
    let exc = (eCoord?.exc) ? true : false;
    let centerCoord;
    let feature;
    let parsePoints;
    let lon, lat, radius;
    let centerPoint, startPoint, endPoint, angleStart, angleEnd;
    const numPoints = 200; // Number of points to approximate the semicircle
    const coordinates = [];
    let semiCirclePolygon;
    let angleStep;
    let excCenterPoint, excRadius, combinedCoords, combinedPolygon, excCoords, excCirclePolygon, difference;
    let semiCircleCoords = [];

    switch (type) {
      case 'polygon':
        if (exc) {
          console.log("polygon ì¸ë° exc ìˆì„ ë–„");
        } else {
          parsePoints = parsePolygonCoordinates(eCoord.polygon, type);
          centerCoord = calculatePolygonCenter(parsePoints[0]);
          feature = new Feature({
            geometry: new Polygon(
              parsePoints
            ),
          });
        }
        break;
      case 'circle': // circleì€ eCoordì— ëª…ì‹œëœ ê²ƒ, ëª…ì‹œì•ˆëœ ê²ƒ ë‘ ê°€ì§€ ì¡´ì¬.
        if (eCoord) {
          lon = eCoord.circle.centerPoint.lon;
          lat = eCoord.circle.centerPoint.lat;
          radius = eCoord.circle.radius;
        } else {
          lon = qCoord.data.lon;
          lat = qCoord.data.lat;
          radius = qCoord.data.radius;
        }

        if (exc) {
          console.log('circle ì¸ë° exc ìˆì„ ë–„');
        } else {
          centerCoord = transform([lon, lat], 'EPSG:4326', 'EPSG:5179')
          if (radius < 999) { // ì¼ì •í¬ê¸° ì´ìƒ featureëŠ” ì•„ì´ì½˜ë§Œ í‘œì‹œ
            let rad = nauticalMilesToMeters(radius);

            feature = new Feature({
              geometry: new Circle([centerCoord[0], centerCoord[1]], rad)
            });

          }
        }

        break;
      case 'semicircle':
        if (exc) { // excê°€ ì¡´ì¬í•˜ë©´ í•´ë‹¹ ì˜ì—­ ì œì™¸í•´ì£¼ê¸°
          centerPoint = [eCoord.semicircle.centerPoint.lon, eCoord.semicircle.centerPoint.lat];
          startPoint = [eCoord.semicircle.startPoint.lon, eCoord.semicircle.startPoint.lat];
          endPoint = [eCoord.semicircle.endPoint.lon, eCoord.semicircle.endPoint.lat];

          centerPoint = transform(centerPoint, 'EPSG:4326', 'EPSG:5179')
          centerCoord = centerPoint;
          startPoint = transform(startPoint, 'EPSG:4326', 'EPSG:5179')
          endPoint = transform(endPoint, 'EPSG:4326', 'EPSG:5179');

          radius = nauticalMilesToMeters(eCoord.semicircle.radius); // ë°˜ì§€ë¦„ ë¯¸í„°ë¡œ ë³€í™˜

          // Calculate the angle for the start and end points
          angleStart = Math.atan2(startPoint[1] - centerPoint[1], startPoint[0] - centerPoint[0]);
          angleEnd = Math.atan2(endPoint[1] - centerPoint[1], endPoint[0] - centerPoint[0]);

          if (eCoord.semicircle.direction === 'CLOCKWISE') {
            angleStep = (angleStart - angleEnd) / numPoints;
          } else {
            angleStep = (angleEnd - angleStart) / numPoints;
          }

          // ê·¸ë ¤ì ¸ì•¼í•  ë°˜ì› ì¢Œí‘œ ìƒì„±
          for (let i = 0; i <= numPoints; i++) {
            const angle = angleStart + i * angleStep;
            const x = centerPoint[0] + radius * Math.cos(angle);
            const y = centerPoint[1] + radius * Math.sin(angle);
            semiCircleCoords.push([x, y]);
          }

          // Add the center and end point to complete the path
          semiCircleCoords.push(centerPoint);
          semiCircleCoords.push(startPoint); // Add start point to close the shape

          if (semiCircleCoords[0][0] !== semiCircleCoords[semiCircleCoords.length - 1][0] ||
            semiCircleCoords[0][1] !== semiCircleCoords[semiCircleCoords.length - 1][1]) {
            semiCircleCoords.push(semiCircleCoords[0]);
          }

          // ì œì™¸í•´ì•¼í•  exc ì› ì¢Œí‘œ ìƒì„±
          excCenterPoint = transform([eCoord.exc.circle.centerPoint.lon, eCoord.exc.circle.centerPoint.lat], 'EPSG:4326', 'EPSG:5179');
          excRadius = nauticalMilesToMeters(eCoord.exc.circle.radius);

          excCoords = [];
          for (let i = 0; i <= numPoints; i++) {
            const angle = 2 * Math.PI * i / numPoints;
            const x = excCenterPoint[0] + excRadius * Math.cos(angle);
            const y = excCenterPoint[1] + excRadius * Math.sin(angle);
            excCoords.push([x, y]);
          }

          // Ensure the polygon is closed
          if (excCoords[0][0] !== excCoords[excCoords.length - 1][0] ||
            excCoords[0][1] !== excCoords[excCoords.length - 1][1]) {
            excCoords.push(excCoords[0]);
          }

          // Turf.jsë¥¼ ì‚¬ìš©í•˜ì—¬ ë°˜ì›ì—ì„œ ì›ì„ ì œì™¸í•œ ì˜ì—­ ìƒì„±
          semiCirclePolygon = turf.polygon([semiCircleCoords]);
          excCirclePolygon = turf.polygon([excCoords]);

          difference = turf.difference(turf.featureCollection([semiCirclePolygon, excCirclePolygon]));

          // Check if difference result is valid
          if (!difference || !difference.geometry || !difference.geometry.coordinates.length) {
            console.error("Invalid result from turf.difference");
            return;
          }

          // Feature ìƒì„±
          combinedPolygon = new Polygon(difference.geometry.coordinates);
          feature = new Feature({
            geometry: combinedPolygon,
          });

        } else {
          //ìš°ì„  ê·¸ë¦¬ê¸°ë¶€í„° í•´ë³´ì..
          centerPoint = [eCoord.semicircle.centerPoint.lon, eCoord.semicircle.centerPoint.lat];
          startPoint = [eCoord.semicircle.startPoint.lon, eCoord.semicircle.startPoint.lat];
          endPoint = [eCoord.semicircle.endPoint.lon, eCoord.semicircle.endPoint.lat];

          centerPoint = transform(centerPoint, 'EPSG:4326', 'EPSG:5179')
          centerCoord = centerPoint;
          startPoint = transform(startPoint, 'EPSG:4326', 'EPSG:5179')
          endPoint = transform(endPoint, 'EPSG:4326', 'EPSG:5179');

          radius = nauticalMilesToMeters(eCoord.semicircle.radius); // in meters

          // Calculate the angle for the start and end points
          angleStart = Math.atan2(startPoint[1] - centerPoint[1], startPoint[0] - centerPoint[0]);
          angleEnd = Math.atan2(endPoint[1] - centerPoint[1], endPoint[0] - centerPoint[0]);

          if (eCoord.semicircle.direction === 'CLOCKWISE') {
            angleStep = (angleStart - angleEnd) / numPoints;
          } else {
            angleStep = (angleEnd - angleStart) / numPoints;
          }

          // ë°˜ì› ì¢Œí‘œ ìƒì„±
          for (let i = 0; i <= numPoints; i++) {
            const angle = angleStart + i * angleStep;
            const x = centerPoint[0] + radius * Math.cos(angle);
            const y = centerPoint[1] + radius * Math.sin(angle);
            semiCircleCoords.push([x, y]);
          }

          // Add the center and end point to complete the path
          semiCircleCoords.push(centerPoint);
          semiCircleCoords.push(startPoint); // Add start point to close the shape
          // Create a polygon from the coordinates
          semiCirclePolygon = new Polygon([semiCircleCoords]);
          feature = new Feature({
            geometry: semiCirclePolygon,
          })

        }
        break;
      case 'polyline':
        if (exc) {
          console.log("polyline ì¸ë° exc ìˆì„ ë–„");
        } else {
          feature = new GeoJSON().readFeature(eCoord.polyline.buffered_polyline, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:5179'
          });

          // polyline featureì˜ ì¤‘ì‹¬ì  êµ¬í•˜ê¸°
          // 1. Front-Endì—ì„œ ê³„ì‚°í•´ì„œ ì²˜ë¦¬
          // const coordinates = parsePolygonCoordinates(eCoord.polyline.line, 'line');
          // centerCoord = calculatePolygonCenter(coordinates);

          // 2. Back-Endì—ì„œ ê³„ì‚°ëœ ê°’ ê·¸ë¦¬ê¸°
          centerCoord = parsePolygonCoordinates(eCoord.polyline.polygon_centroid, 'line')
        }
        break;
      default:
        console.log(`Unknown type: ${notamNo}, ${type}`);
    }

    //radius 999ê°™ì€ ê²ƒë“¤ì€ feature ìƒì„±ì•ˆí•¨.
    if(feature) feature.set('notamNo', notamNo);

    return [feature, centerCoord];
  }
```